#!/usr/bin/env python3
"""
Script avanzato per la gestione delle versioni LeenO con:
- Validazione robusta del formato
- Supporto per versioni STABLE/TESTING
- Logging dettagliato
- Gestione degli errori migliorata
"""

import os
import re
import logging
import argparse
from datetime import datetime
from pathlib import Path
from typing import Dict

# Configurazione logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

class VersionManager:
    """Gestisce tutte le operazioni relative al versionamento"""
    
    VERSION_PATTERN = re.compile(
        r'^LeenO-'
        r'(?P<major>\d+)\.(?P<minor>\d+)\.(?P<patch>\d+)\.(?P<build>\d+)-'
        r'(?P<type>STABLE|TESTING)-'
        r'(?P<date>\d{8})$'
    )
    
    def __init__(self, repo_root: Path):
        self.repo_root = repo_root
        self.version_file = repo_root / 'src' / 'Ultimus.oxt' / 'leeno_version_code'
        self.include_dir = repo_root / 'include'
        
        # Validazione percorsi
        if not self.version_file.exists():
            raise FileNotFoundError(f"File di versione non trovato: {self.version_file}")
        self.include_dir.mkdir(exist_ok=True)

    def parse_current_version(self) -> Dict[str, str]:
        """Analizza la versione corrente con validazione robusta"""
        try:
            with open(self.version_file, 'r') as f:
                version_str = f.read().strip()
                logger.info(f"Versione corrente: {version_str}")
                
                match = self.VERSION_PATTERN.match(version_str)
                if not match:
                    raise ValueError(f"Formato versione non valido: {version_str}")
                
                return {
                    'full': version_str,
                    'major': match.group('major'),
                    'minor': match.group('minor'),
                    'patch': match.group('patch'),
                    'build': match.group('build'),
                    'type': match.group('type'),
                    'date': match.group('date'),
                    'semver': f"{match.group('major')}.{match.group('minor')}.{match.group('patch')}"
                }
                
        except Exception as e:
            logger.error(f"Errore nel parsing della versione: {str(e)}")
            raise

    def generate_new_version(self, current: Dict[str, str], version_type: str = None) -> Dict[str, str]:
        """Genera una nuova versione mantenendo i numeri di versione esistenti"""
        now = datetime.utcnow()
        build_number = os.getenv('BUILD_NUMBER', current['build'])
        git_sha = os.getenv('GITHUB_SHA', 'local')[:7]
        
        # Mantiene il tipo di versione esistente se non specificato
        version_type = version_type if version_type else current['type']
        
        new_version = {
            'full': f"LeenO-{current['major']}.{current['minor']}.{current['patch']}.{build_number}-{version_type}-{now.strftime('%Y%m%d')}",
            'major': current['major'],
            'minor': current['minor'],
            'patch': current['patch'],
            'build_number': build_number,
            'build_date': now.strftime("%Y-%m-%d"),
            'build_time': now.strftime("%H:%M:%S"),
            'git_sha': git_sha,
            'type': version_type,
            'semver': current['semver']
        }
        
        logger.info(f"Nuova versione generata: {new_version['full']}")
        return new_version

    def update_version_files(self, current: Dict[str, str], new: Dict[str, str]) -> None:
        """Aggiorna tutti i file relativi alla versione"""
        try:
            # Aggiorna il file di versione principale
            with open(self.version_file, 'w') as f:
                f.write(new['full'])
            
            # Genera l'header C++
            self._generate_version_header(current, new)
            
            logger.info("File di versione aggiornati con successo")
            
        except Exception as e:
            logger.error(f"Errore nell'aggiornamento dei file: {str(e)}")
            raise

    def _generate_version_header(self, version_info: Dict[str, str], build_info: Dict[str, str]) -> None:
        """Genera il file version.h per C++"""
        header_content = f"""// Auto-generated by version generator
#ifndef LEENO_VERSION_H
#define LEENO_VERSION_H

// Version information
#define LEENO_VERSION_MAJOR {version_info['major']}
#define LEENO_VERSION_MINOR {version_info['minor']}
#define LEENO_VERSION_PATCH {version_info['patch']}
#define LEENO_VERSION_BUILD {build_info['build_number']}
#define LEENO_VERSION_STRING "{version_info['semver']}"
#define LEENO_VERSION_FULL "{build_info['full']}"
#define LEENO_VERSION_TYPE "{build_info['type']}"

// Build information
#define LEENO_BUILD_NUMBER "{build_info['build_number']}"
#define LEENO_BUILD_DATE "{build_info['build_date']}"
#define LEENO_BUILD_TIME "{build_info['build_time']}"
#define LEENO_GIT_SHA "{build_info['git_sha']}"

// Compatibility macros
#define LEENO_VERSION_CODE(major, minor, patch) \\
    ((major << 24) | (minor << 16) | (patch << 8))
#define LEENO_VERSION_CHECK(major, minor, patch) \\
    (LEENO_VERSION_CODE(major, minor, patch) <= LEENO_VERSION_CODE(\\
        LEENO_VERSION_MAJOR, \\
        LEENO_VERSION_MINOR, \\
        LEENO_VERSION_PATCH))

#endif // LEENO_VERSION_H
"""
        
        with open(self.include_dir / 'version.h', 'w') as f:
            f.write(header_content)
        logger.debug("File version.h generato")

def parse_args():
    """Configura gli argomenti da riga di comando"""
    parser = argparse.ArgumentParser(description='Generatore di versioni LeenO')
    parser.add_argument(
        '--type',
        choices=['STABLE', 'TESTING'],
        default=None,
        help='Tipo di build (STABLE/TESTING)'
    )
    parser.add_argument(
        '--repo-root',
        type=Path,
        default=Path(__file__).parent.parent.parent,
        help='Percorso root del repository'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Abilita logging debug'
    )
    return parser.parse_args()

def main():
    args = parse_args()
    
    if args.debug:
        logger.setLevel(logging.DEBUG)
    
    try:
        logger.info("Avvio generazione versione LeenO")
        
        # Inizializza il version manager
        vm = VersionManager(args.repo_root)
        
        # Analizza la versione corrente
        current_version = vm.parse_current_version()
        
        # Genera nuova versione (mantenendo i numeri di versione)
        new_version = vm.generate_new_version(
            current_version,
            version_type=args.type
        )
        
        # Aggiorna i file
        vm.update_version_files(current_version, new_version)
        
        logger.info("Processo completato con successo")
        return 0
        
    except Exception as e:
        logger.critical(f"Errore critico: {str(e)}", exc_info=args.debug)
        return 1

if __name__ == "__main__":
    exit(main())

########################################################################
########################################################################
########################################################################
########################################################################
#!/usr/bin/env python3
"""
Script avanzato per la gestione delle versioni LeenO con:
- Validazione robusta del formato
- Supporto per versioni STABLE/TESTING
- Generazione di version.h e versions.html
- Logging dettagliato
- Gestione degli errori migliorata
"""

import os
import re
import logging
import argparse
from datetime import datetime
from pathlib import Path
from typing import Dict

# Configurazione logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

class VersionManager:
    """Gestisce tutte le operazioni relative al versionamento"""
    
    VERSION_PATTERN = re.compile(
        r'^LeenO-'
        r'(?P<major>\d+)\.(?P<minor>\d+)\.(?P<patch>\d+)\.(?P<build>\d+)-'
        r'(?P<type>STABLE|TESTING)-'
        r'(?P<date>\d{8})$'
    )
    
    def __init__(self, repo_root: Path):
        self.repo_root = repo_root
        self.version_file = repo_root / 'src' / 'Ultimus.oxt' / 'leeno_version_code'
        self.include_dir = repo_root / 'include'
        self.tools_version_dir = repo_root / 'tools' / 'version'  # Directory specificata
        
        # Validazione percorsi
        if not self.version_file.exists():
            raise FileNotFoundError(f"File di versione non trovato: {self.version_file}")
        self.include_dir.mkdir(exist_ok=True)
        self.tools_version_dir.mkdir(exist_ok=True)  # Crea la directory se non esiste

    def parse_current_version(self) -> Dict[str, str]:
        """Analizza la versione corrente con validazione robusta"""
        try:
            with open(self.version_file, 'r') as f:
                version_str = f.read().strip()
                logger.info(f"Versione corrente: {version_str}")
                
                match = self.VERSION_PATTERN.match(version_str)
                if not match:
                    raise ValueError(f"Formato versione non valido: {version_str}")
                
                return {
                    'full': version_str,
                    'major': match.group('major'),
                    'minor': match.group('minor'),
                    'patch': match.group('patch'),
                    'build': match.group('build'),
                    'type': match.group('type'),
                    'date': match.group('date'),
                    'semver': f"{match.group('major')}.{match.group('minor')}.{match.group('patch')}"
                }
                
        except Exception as e:
            logger.error(f"Errore nel parsing della versione: {str(e)}")
            raise

    def generate_new_version(self, current: Dict[str, str], version_type: str = None) -> Dict[str, str]:
        """Genera una nuova versione mantenendo i numeri di versione esistenti"""
        now = datetime.utcnow()
        build_number = os.getenv('BUILD_NUMBER', current['build'])
        git_sha = os.getenv('GITHUB_SHA', 'local')[:7]
        
        # Mantiene il tipo di versione esistente se non specificato
        version_type = version_type if version_type else current['type']
        
        new_version = {
            'full': f"LeenO-{current['major']}.{current['minor']}.{current['patch']}.{build_number}-{version_type}-{now.strftime('%Y%m%d')}",
            'major': current['major'],
            'minor': current['minor'],
            'patch': current['patch'],
            'build_number': build_number,
            'build_date': now.strftime("%Y-%m-%d"),
            'build_time': now.strftime("%H:%M:%S"),
            'git_sha': git_sha,
            'type': version_type,
            'semver': current['semver']
        }
        
        logger.info(f"Nuova versione generata: {new_version['full']}")
        return new_version

    def _generate_version_header(self, version_info: Dict[str, str], build_info: Dict[str, str]) -> None:
        """Genera il file version.h per C++"""
        header_content = f"""// Auto-generated by version generator
#ifndef LEENO_VERSION_H
#define LEENO_VERSION_H

// Version information
#define LEENO_VERSION_MAJOR {version_info['major']}
#define LEENO_VERSION_MINOR {version_info['minor']}
#define LEENO_VERSION_PATCH {version_info['patch']}
#define LEENO_VERSION_BUILD {build_info['build_number']}
#define LEENO_VERSION_STRING "{version_info['semver']}"
#define LEENO_VERSION_FULL "{build_info['full']}"
#define LEENO_VERSION_TYPE "{build_info['type']}"

// Build information
#define LEENO_BUILD_NUMBER "{build_info['build_number']}"
#define LEENO_BUILD_DATE "{build_info['build_date']}"
#define LEENO_BUILD_TIME "{build_info['build_time']}"
#define LEENO_GIT_SHA "{build_info['git_sha']}"

// Compatibility macros
#define LEENO_VERSION_CODE(major, minor, patch) \\
    ((major << 24) | (minor << 16) | (patch << 8))
#define LEENO_VERSION_CHECK(major, minor, patch) \\
    (LEENO_VERSION_CODE(major, minor, patch) <= LEENO_VERSION_CODE(\\
        LEENO_VERSION_MAJOR, \\
        LEENO_VERSION_MINOR, \\
        LEENO_VERSION_PATCH))

#endif // LEENO_VERSION_H
"""
        
        with open(self.include_dir / 'version.h', 'w') as f:
            f.write(header_content)
        logger.debug("File version.h generato")

    def _generate_versions_html(self, version_info: Dict[str, str], build_info: Dict[str, str]) -> None:
        """Genera il file versions.html nella directory tools/version"""
        html_content = f"""<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Versioni LeenO - {version_info['full']}</title>
    <style>
        body {{ 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6; 
            margin: 20px;
            color: #333;
        }}
        h1 {{ color: #2c3e50; }}
        .version-info {{ 
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }}
        th, td {{
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background-color: #3498db;
            color: white;
        }}
        .badge {{
            display: inline-block;
            padding: 3px 7px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }}
        .stable {{ background-color: #2ecc71; color: white; }}
        .testing {{ background-color: #f39c12; color: white; }}
    </style>
</head>
<body>
    <h1>Informazioni Versione LeenO</h1>
    
    <div class="version-info">
        <h2>Dettagli Versione</h2>
        <table>
            <tr>
                <th>Versione Completa</th>
                <td>{version_info['full']}</td>
            </tr>
            <tr>
                <th>Versione Semantica</th>
                <td>{version_info['semver']}</td>
            </tr>
            <tr>
                <th>Tipo Build</th>
                <td><span class="badge {build_info['type'].lower()}">{build_info['type']}</span></td>
            </tr>
        </table>
    </div>
    
    <div class="version-info">
        <h2>Informazioni Build</h2>
        <table>
            <tr>
                <th>Numero Build</th>
                <td>{build_info['build_number']}</td>
            </tr>
            <tr>
                <th>Data Build</th>
                <td>{build_info['build_date']}</td>
            </tr>
            <tr>
                <th>Ora Build</th>
                <td>{build_info['build_time']}</td>
            </tr>
            <tr>
                <th>Commit Git</th>
                <td><code>{build_info['git_sha']}</code></td>
            </tr>
        </table>
    </div>
</body>
</html>
"""
        
        html_file = self.tools_version_dir / 'versions.html'
        with open(html_file, 'w') as f:
            f.write(html_content)
        logger.info(f"File versions.html generato in: {html_file}")

    def update_version_files(self, current: Dict[str, str], new: Dict[str, str]) -> None:
        """Aggiorna tutti i file relativi alla versione"""
        try:
            # Aggiorna il file di versione principale
            with open(self.version_file, 'w') as f:
                f.write(new['full'])
            
            # Genera l'header C++
            self._generate_version_header(current, new)
            
            # Genera la pagina HTML
            self._generate_versions_html(current, new)
            
            logger.info("File di versione aggiornati con successo")
            
        except Exception as e:
            logger.error(f"Errore nell'aggiornamento dei file: {str(e)}")
            raise

def parse_args():
    """Configura gli argomenti da riga di comando"""
    parser = argparse.ArgumentParser(description='Generatore di versioni LeenO')
    parser.add_argument(
        '--type',
        choices=['STABLE', 'TESTING'],
        default=None,
        help='Tipo di build (STABLE/TESTING)'
    )
    parser.add_argument(
        '--repo-root',
        type=Path,
        default=Path(__file__).parent.parent.parent,
        help='Percorso root del repository'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Abilita logging debug'
    )
    return parser.parse_args()

def main():
    args = parse_args()
    
    if args.debug:
        logger.setLevel(logging.DEBUG)
    
    try:
        logger.info("Avvio generazione versione LeenO")
        
        # Inizializza il version manager
        vm = VersionManager(args.repo_root)
        
        # Analizza la versione corrente
        current_version = vm.parse_current_version()
        
        # Genera nuova versione (mantenendo i numeri di versione)
        new_version = vm.generate_new_version(
            current_version,
            version_type=args.type
        )
        
        # Aggiorna i file
        vm.update_version_files(current_version, new_version)
        
        logger.info("Processo completato con successo")
        return 0
        
    except Exception as e:
        logger.critical(f"Errore critico: {str(e)}", exc_info=args.debug)
        return 1

if __name__ == "__main__":
    exit(main())