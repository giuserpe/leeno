#!/usr/bin/env python3
"""
Script aggiornato per leggere il formato specifico di leeno_version_code
"""

import os
import re
from datetime import datetime
from pathlib import Path

def read_version_code():
    """Legge il codice versione dal file leeno_version_code nel formato specifico"""
    version_file = Path(__file__).parent.parent.parent / 'src' / 'Ultimus.oxt' / 'leeno_version_code'
    try:
        with open(version_file, 'r') as f:
            content = f.read()
            
            # Estrae i componenti separati dal formato originale
            major = re.search(r'VersionMajor\s*=\s*(\d+)', content)
            minor = re.search(r'VersionMinor\s*=\s*(\d+)', content)
            patch = re.search(r'VersionPatch\s*=\s*(\d+)', content)
            
            if not all([major, minor, patch]):
                raise ValueError("Formato versione non valido: mancano VersionMajor/Minor/Patch")
                
            return f"{major.group(1)}.{minor.group(1)}.{patch.group(1)}"
            
    except Exception as e:
        print(f"ERRORE leggendo leeno_version_code: {str(e)}")
        print("Assicurati che il file contenga VersionMajor, VersionMinor e VersionPatch")
        raise

def generate_build_info():
    """Genera informazioni sulla build"""
    now = datetime.utcnow()
    git_sha = os.getenv('GITHUB_SHA', 'local')[:7]
    return {
        'build_date': now.strftime("%Y-%m-%d"),
        'build_time': now.strftime("%H:%M:%S"),
        'build_number': os.getenv('BUILD_NUMBER', now.strftime("%Y%m%d%H%M")),
        'git_sha': git_sha
    }

def update_version_code(version, build_info):
    """Aggiorna il file leeno_version_code mantenendo il formato originale"""
    version_file = Path(__file__).parent.parent.parent / 'src' / 'Ultimus.oxt' / 'leeno_version_code'
    major, minor, patch = version.split('.')
    
    new_content = f"""// Auto-generated by version generator
VersionMajor = {major}
VersionMinor = {minor}
VersionPatch = {patch}
BuildDate = "{build_info['build_date']}"
BuildTime = "{build_info['build_time']}"
BuildNumber = "{build_info['build_number']}"
GitCommit = "{build_info['git_sha']}"
"""
    
    with open(version_file, 'w') as f:
        f.write(new_content)

def generate_version_header(version, build_info):
    """Genera il file version.h per C++"""
    include_dir = Path(__file__).parent.parent.parent / 'include'
    include_dir.mkdir(exist_ok=True)
    
    header_content = f"""// Auto-generated by version generator
#ifndef LEENO_VERSION_H
#define LEENO_VERSION_H

#define LEENO_VERSION_MAJOR {version.split('.')[0]}
#define LEENO_VERSION_MINOR {version.split('.')[1]}
#define LEENO_VERSION_PATCH {version.split('.')[2]}
#define LEENO_VERSION_STRING "{version}"
#define LEENO_BUILD_NUMBER "{build_info['build_number']}"
#define LEENO_BUILD_DATE "{build_info['build_date']}"
#define LEENO_BUILD_TIME "{build_info['build_time']}"
#define LEENO_GIT_SHA "{build_info['git_sha']}"

#endif // LEENO_VERSION_H
"""
    
    with open(include_dir / 'version.h', 'w') as f:
        f.write(header_content)

def main():
    try:
        print("Generazione informazioni versione Leeno...")
        
        version = read_version_code()
        build_info = generate_build_info()
        
        print(f"Versione: {version}")
        print(f"Numero build: {build_info['build_number']}")
        print(f"Commit Git: {build_info['git_sha']}")
        
        update_version_code(version, build_info)
        generate_version_header(version, build_info)
        
        print("File versione generati con successo!")
        return 0
        
    except Exception as e:
        print(f"ERRORE: {str(e)}")
        return 1

if __name__ == "__main__":
    exit(main())